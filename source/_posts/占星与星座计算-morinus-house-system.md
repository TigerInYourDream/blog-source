---
title: 占星与星座计算 morinus house system
categories:
  - 天文学
tags:
  - 占星
abbrlink: 26767
date: 2021-08-10 22:37:53
---

# 占星与星座计算 morinus house system

在系列前三节，已经基本介绍了和占星有关的模型，基本的分宫制的原理和占星以及天文中所出现的术语，这一节将带大家进行一次实际的占星计算。本文仅涉及星盘的计算，不涉及其他。

本文的重点是星盘的计算。本文将采用莫林分宫制morinus house system！至于为什么选择莫林分宫制，是因为莫林分宫制可以找到具体的数学计算公式，便于计算。且莫林分宫制在高纬度地区受到的扭曲小。至于分宫制的基本原理，可以查看上一节分宫制基本原理。

> 对于“morinus house system”是有专门的计算方法，通过一系列的加减乘除算出一个人出生时的MC、Asc以及每个宫头所在得度数，就可以排出一个近乎完整的星图了。

> ASC：东升点是在诞生时刻在诞生地点的东面地平与黄道交接的一点

> MC：天顶

我们在计算的时候需要以下参数

1. 当事人的出生位置，需要从具体地点转化成经纬度
2. 出生时间，需要转化为恒星时
3. 黄赤交角，这个是固定值。关于黄赤交角可以看第一节天球部分。23°27′
4. 以及如下公式

> MC = arctan(tan(RAMC) / cos(e))

> RAMC为上中天的赤经度数

> 星表上专门有栏目是星星的赤经(希腊字母α)的一般格式是XhXXminXXs.其实概念和地球的东经西经差不多,但不分东西两个方向,就是从0度开始按一定方向到360度(就是开始的地方),更简单了.
> 关于换算,先从角度上看
> 赤经是在天球赤道自西向东由0小时至24 小时。把赤经的一周360度划成24份,一份就是15度.那么很简单了,
> 1小时=15度.
> 时间上的小时和角度上的度的下面的小单位都叫分,秒,换算也都是60.为了不混淆,用时分,时秒和角分,角秒来表示.
> 根据那个原始的换算公式,可以得到1时分=15角分,1时秒=15角秒 。赤经计算的起点为春分点，春分点是太阳在每年的春分（3月21日前后）所处的位置。

注1：所有的数字都要转化为时间

注2：RAMC需要恒星时间换算。

做了概念的准备之后，我们开始选取一个具体的例子进行计算

首先，假设当事人出生得地理位置为（52o 13′ N and 6o 54′ E），荷兰恩斯科德。时间：2016年11月2日（公历），21:17:30（格林尼治时间），恒星时：0:35:23.6，黄赤交角e：23°27′。

想知道什么是恒星时：[点这个](https://zh.wikipedia.org/wiki/%E6%81%92%E6%98%9F%E6%97%B6)

然后把数据代入儒略历和恒星时计算准备的程序中。得到结果

> res 1.9485282441601157°
> The sidereal hour is 0.1299018829440077h
> The sidereal time is 0.0h7.0m47.646778598427716s

得到当时的恒星时为1.95度，转换成时间为0.1299小时。0时7分47秒。

这里的度数就是RAMC 为1.95.

黄赤交角e=23度27分，转化为时间为23.45时（27/60=0.45）

MC= arctan ( TAN (1.95) ÷ COS 23.45 )

计算代码使用rust自带的三角函数，rust中的三角使用的是弧度，我们需要在弧度和角度之间互相转化。

得到中天数为2.12度。根据之前分宫制的计算，三十度为一个宫位。2.12度为一个首宫位白羊座。所以我们可以这样说：MC在白羊座2.12处。

接下来我们计算上升点ASC

> ASC= ARCCOT (- ( (TAN f x SIN e) + (SIN RAMC x COS e) ) ÷ COS RAMC)

因为计算机上没有反余切函数，我们需要换算：

ARCCOT = (π/2) - ARCTAN,这是弧度，角度是90度- ARCTAN。

所以公式可以转换为下面

> ARCTAN(- ( (TAN f x SIN e) + (SIN RAMC x COS e) ) ÷ COS RAMC)

其中f为出生纬度52.21时，已换算.

最终的结果为 119.28330880864735

进入第四宫位的末尾119.2833 - 30*3 = 29.283308808647348度。即便是巨蟹座的29.28度。巨蟹座的尾巴。

```rust
use std::f64::consts::PI;
use std::f64::consts::E;

pub fn to_radians(x: f64) -> f64 {
    x * PI / 180f64
}

pub fn to_angle(x: f64) -> f64 {
    x * 180f64 / PI
}

pub fn houses_system() {
    println!("houses_system!");
    let a = to_radians(1.95f64).tan() / to_radians(23.45f64).cos();
    let mc = a.atan();
    println!("{:?}", to_angle(mc));

    //ARCTAN(- ( (TAN f x SIN e) + (SIN RAMC x COS e) ) ÷ COS RAMC)
    let f = -to_radians(52.21f64).tan() * E.sin() + to_radians(1.95f64).sin() * E.cos();
    println!("{:?}", f);
    let mut asc = to_angle(f.atan());
    println!("asc {:?}", asc);
    if asc < 0f64 {
        asc = 90f64 - asc
    }
    println!("asc {:?}", asc);
}
```

具体的代码还是在上一节的代码中。为了清晰，改变了代码结构。因为展示的是计算过程，代码风格较差。

[https://github.com/TigerInYourDream/sidereal-time](https://github.com/TigerInYourDream/sidereal-time)

对应的相应的各种占星计算也是根据如上的公式进行一步步计算和推演得出的。本文和一些成熟的星盘数据进行了对比，发现有一定的角度偏差。发现主要的差别在恒星时的换算上。但是误差较小，最终导致了最后的ASC上升星座偏差了三度。因为本文查看了相对应的天文论文，对占星的具体算法也有一定争议。需要进一步讨论这个偏差。不过也看出来在古代占星的计算和推演相当的繁复，借助现代计算机对这种计算有了很好的辅助作用。本系列文章只谈论占星中涉及的具体的天文和星盘宫位的计算。

永远仰望天空，永远保持旺盛的好奇心！