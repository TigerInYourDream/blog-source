---
title: 占星与星座计算  儒略历和恒星时计算
tags: '-rust -星座'
abbrlink: 3102
date: 2021-08-07 22:35:15
---

# 占星与星座计算  儒略历和恒星时计算

在前两节的文章基础之上，我们开始进行真正的计算。在介绍计算星盘之前，我们需要一个预先准备的数据。儒略历和恒星时。网上的现成代码似乎没有说的很清楚，公式不够统一，结果也难以验证，为此参考了很多资料。其中有两个资料确定是对的。

[https://zh.wikipedia.org/wiki/恒星时](https://zh.wikipedia.org/wiki/%E6%81%92%E6%98%9F%E6%97%B6)

上面公式中关于儒略历的转化公式是正确的，请注意其中的高斯符号。高斯符号相当于代码中的floor()函数。

后面关于恒星时的计算不确定正确性。

然后参考一份关于天文算法的论文，或者是一本翻译的PDF。感谢“冯剑和他的译友”翻译了这本天文算法，使我得到了确切的公式。

关于什么是恒星时可以也可以参考上面的wiki。

关于结果，分别得到了多项式T，算出来以角度为单位的恒星时，以时间hour为单位的恒星时，以时分秒为单位的恒星时。

> 现在公历纪元的年表示为Y、月为M、日为D、时为h、分为m、秒为s，1月、2月分别当做上一年的13月、14月。（例：2010年1月1日时Y=2009, M=13, D=1），然后求出儒略日
>

计算儒略历请注意以上的重点。

代码如下

```sql
use chrono::{Utc, TimeZone, FixedOffset, Datelike, Timelike};
use num::traits::pow;

fn main() {
    println!("sidereal time!");
    // let birthday = Utc.ymd(1987, 4, 10).and_hms(19, 21, 00);
    let birthday = Utc.ymd(2016, 11, 2).and_hms(21, 17, 30);
    let timezone = FixedOffset::east(0);
    birthday.with_timezone(&timezone);

    let mut year = birthday.year() as f64;
    let mut month = birthday.month() as f64;
    let day = birthday.day() as f64;
    let hour = birthday.hour() as f64;
    let minute = birthday.minute() as f64;
    let second = birthday.second() as f64;

    if month < 2f64 {
        year = year - 1f64;
        month = month + 12f64;
    }

    let jd = (&365.25 * year).floor() + (year / 400f64).floor() - (&year / 100f64).floor() + (30.59 * (month - 2f64)).floor()
        + day + 1721088.5 + hour / 24f64 + minute / 1440f64 + second / 86400f64;
    println!("jd: {:?}", jd);

    let t = (jd - 2451545.0) / 36525f64;
    println!("t: {:?}", t);
    let g = 280.46061837 + 360.98564736629 * (jd - 2451545.0) + 0.000387933 * pow(t, 2) - pow(t, 3) / 38710000f64;
    println!("g: {:?}", g);
    let mut res = g % 360f64;
    if res < 0f64 {
        res = 360f64 + res;
    }
    println!("res {:?}°", res);

    res = res / 15f64;
    println!("The sidereal hour is {:?}h", res);

    let hour = res.floor();
    let minute = ((res - hour) * 60f64).floor();
    let second = (((res - hour) * 60f64) - minute) * 60f64;
    println!("The sidereal time is {:?}h{:?}m{:?}s", hour, minute, second);
}
```

其中jd代表儒略历时间。

儒略历的计算结果可以对比

[https://www.aavso.org/jd-calculator](https://www.aavso.org/jd-calculator)

可以确定计算是一致的，也就验证了wiki中的公式的正确。后半部分则是引用了论文中的公式，计算结果和示例推导过程一致。所以计算结果可以确定是对的。顺便吐槽某个占星网站的计算，其中恒星时是错误的，伪学不靠谱啊。

关于代码：代码使用rust，使用了chrono库表示时间。也使用了num，不过似乎也没用到什么特性，只用了一个pow。为了保证精度，所有数字全部使用f64

另外本期计算的是平恒星时，非视恒星时。不考虑赤经章动修正。

代码在github已上传。

[**https://github.com/TigerInYourDream/sidereal-time**](https://github.com/TigerInYourDream/sidereal-time)
